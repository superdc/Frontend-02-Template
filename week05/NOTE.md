## 学习笔记

本周跟随老师完成了 CSS 计算，排版和绘制的代码编写。

## CSS 计算

1. 遇到 style 标签时，在标签闭合时，保存 css 规则
   - 利用 css npm 包来解析  css 规则
2. 创建 element 元素时，计算 css，将匹配的 css 规则加上 element 上
   - 匹配 css 规则时，按选择器从后向前的顺序计算是否与当前元素及所有父元素匹配，父元素序列由堆栈确定
   - 复杂选择器拆成单个元素的选择器，用循环匹配父元素序列
   - 单个元素选择器可能是简单选择器，也可能是复合选择器
   - 匹配的过程中计算选择器的优先级，用数组表示 [inline, id, class, tag]，优先级从左到右一次降低。优先级比较的规则是从高优先级到低优先级依次比较，若高位不同，则比较结束。确定了相同 css 规则的覆盖问题。

## 排版

1. 只针对 flex 布局元素进行排版

2. 要了解 flex 布局的规则

3. 目标：确定每个元素在主轴和交叉轴上的位置

   ![image](https://user-images.githubusercontent.com/8255083/89121182-4cdc4e00-d4ef-11ea-9c31-027beebba913.png)

4. 计算步骤：
   - 预处理：将 CSS 规则中的带有 'px' 单位或者为数字的 css 属性值转化为数字，方便后面计算
   - 给`display: flex`的元素添加 flex 布局相关的属性。若没设置，则添加默认值
   - 计算主轴方向
     - 找出所有 flex 元素
     - 把主轴方向的剩余尺寸按比例分配给这些元素
       - 设置了 flex，按比例分配
       - 否则按照 justify-content 属性，计算每个元素的起始和结束位置
     - 若剩余空间为负数，设置 flex 的元素认为可以在一行中，进行等比压缩（nowrap 的情况）
   - 计算交叉轴方向
     - 根据每一行中最大元素尺寸计算行高
     - 根据行高、align-items、align-content 确定元素具体位置

## 绘制

用在图片上进行绘制代替在屏幕上绘制

- 依赖一个图形环境：采用 images npm 包
- 根据元素的宽，高绘制图形
- 根据元素的 left, top 确定绘制位置

## 总结

在 toy-browser 的各个阶段都忽略了很多复杂场景

1. html 解析的状态机状态不全
2. css 规则解析只考虑简单选择器，class/id/属性选择器
3. 布局只考虑 flex 布局，并且设置了具体宽高的情况
4. 绘制只根据宽高，背景颜色，位置进行绘制。没有考虑文本绘制，合成层等